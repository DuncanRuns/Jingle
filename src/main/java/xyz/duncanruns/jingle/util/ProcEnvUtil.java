package xyz.duncanruns.jingle.util;

import com.sun.jna.*;
import com.sun.jna.platform.win32.Kernel32;
import com.sun.jna.platform.win32.WinNT;
import com.sun.jna.platform.win32.WinNT.HANDLE;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.win32.W32APIOptions;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Generated by chat gippity.
 * Couldn't find a similar source, it seems like it just did some microsoft docs maxing and JNA maxing.
 */
public class ProcEnvUtil {

    // NtQueryInformationProcess constant
    private static final int ProcessBasicInformation = 0;

    // Offsets for 64-bit Windows 10+
    // (for 32-bit, these values differ!)
    private static final int PEB_OFFSET_ProcessParameters = 0x20;
    private static final int RTL_USER_PROCESS_PARAMETERS_OFFSET_Environment = 0x80;

    // Max environment block size (64 KB is enough for Windows)
    private static final int MAX_ENV_SIZE = 64 * 1024;

    // Structure for PROCESS_BASIC_INFORMATION (simplified)
    public static class PROCESS_BASIC_INFORMATION extends Structure {
        public Pointer Reserved1;
        public Pointer PebBaseAddress;
        public Pointer Reserved2_0;
        public Pointer Reserved2_1;
        public Pointer UniqueProcessId;
        public Pointer Reserved3;

        @Override
        protected List<String> getFieldOrder() {
            return Arrays.asList(
                    "Reserved1",
                    "PebBaseAddress",
                    "Reserved2_0",
                    "Reserved2_1",
                    "UniqueProcessId",
                    "Reserved3"
            );
        }
    }

    // Ntdll interface
    public interface Ntdll extends Library {
        Ntdll INSTANCE = Native.load("Ntdll", Ntdll.class, W32APIOptions.UNICODE_OPTIONS);

        int NtQueryInformationProcess(HANDLE processHandle,
                                      int processInformationClass,
                                      Structure processInformation,
                                      int processInformationLength,
                                      IntByReference returnLength);
    }

    /**
     * Reads the environment variables of another process by PID.
     */
    public static Map<String, String> getEnvironmentVariables(int pid) throws Exception {
        HANDLE process = Kernel32.INSTANCE.OpenProcess(
                WinNT.PROCESS_QUERY_INFORMATION | WinNT.PROCESS_VM_READ,
                false,
                pid
        );
        if (process == null) {
            throw new IllegalStateException("Failed to open process " + pid + ": " +
                    Kernel32.INSTANCE.GetLastError());
        }

        try {
            // Query basic info (gives us PEB address)
            PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
            IntByReference retLen = new IntByReference();

            int status = Ntdll.INSTANCE.NtQueryInformationProcess(
                    process,
                    ProcessBasicInformation,
                    pbi,
                    pbi.size(),
                    retLen
            );
            if (status != 0) {
                throw new IllegalStateException("NtQueryInformationProcess failed: " + status);
            }

            Pointer pebAddress = pbi.PebBaseAddress;

            // Read pointer to ProcessParameters from PEB
            Pointer processParametersAddress = readPointer(process, pebAddress.share(PEB_OFFSET_ProcessParameters));

            // Read pointer to Environment from RTL_USER_PROCESS_PARAMETERS
            Pointer environmentAddress = readPointer(process, processParametersAddress.share(RTL_USER_PROCESS_PARAMETERS_OFFSET_Environment));

            // Read environment block
            Memory buffer = new Memory(MAX_ENV_SIZE);
            IntByReference bytesRead = new IntByReference();

            boolean ok = Kernel32.INSTANCE.ReadProcessMemory(
                    process,
                    environmentAddress,
                    buffer,
                    (int) buffer.size(),
                    bytesRead
            );
            if (!ok) {
                throw new IllegalStateException("ReadProcessMemory failed: " + Kernel32.INSTANCE.GetLastError());
            }

            byte[] data = buffer.getByteArray(0, bytesRead.getValue());
            String envBlock = new String(data, StandardCharsets.UTF_16LE);

            // Truncate at the double-null terminator
            int end = envBlock.indexOf("\u0000\u0000");
            if (end != -1) {
                envBlock = envBlock.substring(0, end);
            }

            String[] vars = envBlock.split("\u0000");


            Map<String, String> env = new LinkedHashMap<>();
            for (String var : vars) {
                if (var.isEmpty()) continue;
                int idx = var.indexOf('=');
                if (idx > 0) {
                    env.put(var.substring(0, idx), var.substring(idx + 1));
                }
            }
            return env;

        } finally {
            Kernel32.INSTANCE.CloseHandle(process);
        }
    }

    /**
     * Helper to read a pointer-sized value from another process.
     */
    private static Pointer readPointer(HANDLE process, Pointer address) {
        Memory buffer = new Memory(Native.POINTER_SIZE);
        IntByReference bytesRead = new IntByReference();

        boolean ok = Kernel32.INSTANCE.ReadProcessMemory(
                process,
                address,
                buffer,
                (int) buffer.size(),
                bytesRead
        );

        if (!ok || bytesRead.getValue() != buffer.size()) {
            throw new IllegalStateException("ReadProcessMemory (pointer) failed: " +
                    Kernel32.INSTANCE.GetLastError());
        }

        long value = (Native.POINTER_SIZE == 8)
                ? buffer.getLong(0)
                : buffer.getInt(0) & 0xFFFFFFFFL;

        return new Pointer(value);
    }
}
